<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KST 이벤트 예매 시스템</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Paperlogy Web Font -->
    <link href="https://cdn.jsdelivr.net/gh/fonts-archive/Paperlogy/Paperlogy.css" rel="stylesheet">
    <style>
        /* Custom Styles for Aesthetics */
        body {
            font-family: 'Paperlogy', sans-serif;
            background-color: #f0f4f8; /* Light blue-gray background */
        }
        .kst-card {
            background-color: white;
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            transition: transform 0.3s ease;
        }
        .kst-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 15px 20px -5px rgba(0, 0, 0, 0.15);
        }
        .btn-primary {
            background-color: #10b981; /* Emerald Green */
            color: white;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        .btn-primary:hover:not(:disabled) {
            background-color: #059669;
        }
        .btn-primary:disabled {
            background-color: #a7f3d0;
            cursor: not-allowed;
        }
        .kst-badge {
            padding: 0.25rem 0.75rem;
            border-radius: 9999px;
            font-size: 0.75rem;
            font-weight: bold;
            display: inline-block;
        }
        .seat-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(40px, 1fr));
            gap: 8px;
            max-width: 600px;
            margin: 0 auto;
            padding: 16px;
            border: 2px solid #e5e7eb;
            border-radius: 0.75rem;
        }
        .seat {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 0.5rem;
            font-size: 0.875rem;
            font-weight: bold;
            transition: background-color 0.2s, transform 0.1s;
        }
        .seat:hover:not(.bg-red-500):not(.bg-blue-500) {
            transform: scale(1.05);
        }
        .is-hidden {
            display: none !important;
        }
    </style>
    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, addDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, where, runTransaction, FieldValue, serverTimestamp, getDocs, limit, orderBy, writeBatch, Timestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // Expose Firebase services to the global scope for use in the script tag
        window.firebase = {
            initializeApp, setLogLevel, getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged,
            getFirestore, doc, getDoc, addDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, where, runTransaction, FieldValue, serverTimestamp, getDocs, limit, orderBy, writeBatch, Timestamp
        };

        // --- 1. Global Setup ---
        
        // Canvas 환경 변수 로드 (필수)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        // setLogLevel('debug'); // 디버그 로깅 활성화 (필요 시 주석 해제)
        const ADMIN_KEY = "rrqq23"; // 관리자 키
        
        let db;
        let auth;
        let userId = null; // 현재 사용자의 UID
        let currentEventData = null; // 현재 선택된 이벤트 정보
        let bookingUserData = null; // 예매자 정보 (이름, 학번, 전화번호)
        let isBooking = false; // 중복 예매/큐 진입 방지 플래그
        let queueListenerUnsubscribe = null; // 큐 리스너 해제 함수
        let editingEventId = null; // 수정 중인 이벤트 ID
        
        let COLLECTIONS = {
            events: 'artifacts/' + appId + '/public/data/events',
            bookings: null, // User specific, defined after auth
            queueStatus: 'artifacts/' + appId + '/public/data/queue_status', // Public queue data
            adminBookings: 'artifacts/' + appId + '/public/data/adminBookings' // Public record of all bookings
        };

        // --- 2. Utility Functions ---
        
        /**
         * Firestore Timestamp를 KST 문자열로 포맷합니다.
         */
        function formatKstTime(timestamp, includeSeconds = false) {
            if (!timestamp || !timestamp.toDate) return '시간 정보 없음';
            const date = timestamp.toDate();
            return date.toLocaleString('ko-KR', { 
                timeZone: 'Asia/Seoul', 
                year: 'numeric', 
                month: '2-digit', 
                day: '2-digit', 
                hour: '2-digit', 
                minute: '2-digit', 
                second: includeSeconds ? '2-digit' : undefined,
                hour12: false 
            }).replace(/\. /g, '/').replace('.', '').trim();
        }
        
        /** KST datetime-local 입력값을 Timestamp로 변환 */
        function getKstTimestamp(datetimeLocalValue) {
            if (!datetimeLocalValue) return null;
            // KST 시간대를 명시적으로 지정하여 Date 객체 생성 (2025-10-20T10:00:00)
            const date = new Date(datetimeLocalValue + ":00+09:00"); 
            return firebase.Timestamp.fromDate(date);
        }
        
        /** 현재 시간을 기준으로 예매 상태 확인 */
        function getBookingStatus(startTime, endTime) {
            const now = firebase.Timestamp.now();
            if (now.seconds < startTime.seconds) {
                return { status: '준비 중', color: 'bg-yellow-500', isAvailable: false };
            }
            if (now.seconds >= startTime.seconds && now.seconds <= endTime.seconds) {
                return { status: '예매 가능', color: 'bg-green-600', isAvailable: true };
            }
            return { status: '예매 종료', color: 'bg-gray-500', isAvailable: false };
        }

        /** 팝업창 대신 우측 상단에 비동기 알림 메시지를 표시합니다. */
        function showMessage(message, type = 'blue', duration = 3000) {
            const app = document.getElementById('app');
            let msgEl = document.getElementById('custom-alert-msg');
            
            if (!msgEl) {
                msgEl = document.createElement('div');
                msgEl.id = 'custom-alert-msg';
                msgEl.className = 'fixed top-4 right-4 z-[100] p-4 rounded-lg shadow-xl text-white font-semibold transition-all duration-300 transform translate-y-full opacity-0';
                document.body.appendChild(msgEl); 
            }
            
            msgEl.textContent = message;
            
            const colors = {
                blue: 'bg-blue-600',
                green: 'bg-green-600',
                red: 'bg-red-600',
                yellow: 'bg-yellow-600',
                warning: 'bg-orange-500',
                error: 'bg-red-600',
                success: 'bg-green-600'
            };
            msgEl.className = msgEl.className.split(' ').filter(c => !c.startsWith('bg-')).join(' ') + ' ' + (colors[type] || colors.blue);

            msgEl.classList.remove('opacity-0', 'translate-y-full');
            msgEl.classList.add('opacity-100', 'translate-y-0');

            setTimeout(() => {
                msgEl.classList.remove('opacity-100', 'translate-y-0');
                msgEl.classList.add('opacity-0', 'translate-y-full');
            }, duration);
        }
        window.showMessage = showMessage;

        /** 로딩 인디케이터 표시/숨김 */
        function showLoading(show, text = "처리 중...") {
            const el = document.getElementById('global-loading');
            if (!el) return;
            if (show) {
                el.querySelector('#loading-text').textContent = text;
                el.classList.remove('hidden');
            } else {
                el.classList.add('hidden');
            }
        }
        window.showLoading = showLoading;
        
        /** 모달 표시/숨김 (예매 완료/관리자 알림 등) */
        function showGlobalModal(show, title, contentHTML, buttonsHTML = '', size = 'max-w-md') {
            const modalEl = document.getElementById('global-modal');
            if (!modalEl) return;
            const contentContainer = document.getElementById('global-modal-content');

            if (show) {
                contentContainer.className = `bg-white p-6 rounded-xl shadow-2xl w-full ${size} text-center`;
                modalEl.querySelector('#global-modal-title').textContent = title;
                modalEl.querySelector('#global-modal-body').innerHTML = contentHTML;
                modalEl.querySelector('#global-modal-buttons').innerHTML = buttonsHTML;
                modalEl.classList.remove('is-hidden');
            } else {
                modalEl.classList.add('is-hidden');
            }
        }
        window.showGlobalModal = showGlobalModal;


        // --- 3. UI Control and View State ---

        let views = {}; // DOM 로드 후 초기화
        
        /** 뷰 전환 함수 */
        function setView(activeView) {
            // Unsubscribe from any active listeners when changing views
            if (queueListenerUnsubscribe) {
                queueListenerUnsubscribe();
                queueListenerUnsubscribe = null;
            }
            
            const queueModal = document.getElementById('queue-modal');
            const globalModal = document.getElementById('global-modal');

            if (queueModal) queueModal.classList.add('is-hidden'); // 큐 모달 닫기
            if (globalModal) globalModal.classList.add('is-hidden'); // 일반 모달 닫기

            Object.values(views).forEach(v => v.classList.add('hidden'));
            if (activeView) {
                activeView.classList.remove('hidden');
                if (activeView === views.admin) {
                    loadAdminEvents(); // 관리자 뷰로 전환 시 이벤트 목록 로드
                }
            }
        }

        /** 이벤트 목록 뷰로 전환 */
        function showEventList() {
            setView(views.list);
        }
        window.showEventList = showEventList;

        /** 예매자 정보 저장 */
        function setBookingUserData(data) {
            bookingUserData = data;
            const summaryNameEl = document.getElementById('summary-name');
            const summaryStudentIdEl = document.getElementById('summary-student-id');
            if (summaryNameEl) summaryNameEl.textContent = data.name;
            if (summaryStudentIdEl) summaryStudentIdEl.textContent = data.studentId;
            COLLECTIONS.bookings = 'artifacts/' + appId + '/users/' + userId + '/bookings';
        }

        /** 예매 오류 메시지 숨김 */
        function hideBookingError() {
            const errorEl = document.getElementById('booking-error-msg');
            if (errorEl) {
                errorEl.classList.add('hidden');
                errorEl.textContent = '';
            }
        }

        /** 관리자 모드 전환 */
        window.toggleAdminView = function() {
            const key = prompt("관리자 키를 입력하세요:");
            if (key === ADMIN_KEY) {
                showMessage("관리자 모드로 전환합니다.", 'success');
                setView(views.admin);
            } else if (key !== null) {
                showMessage("잘못된 관리자 키입니다.", 'error');
            }
        };

        /** 관리자 모드 해제 */
        window.exitAdminView = function() {
            showMessage("관리자 모드를 종료합니다.", 'blue');
            resetAdminForm();
            showEventList();
        }
        
        // --- 4. Event Detail and Booking Start ---

        /** 이벤트 상세 뷰 표시 */
        window.showEventDetail = async (eventId) => {
            showLoading(true, "이벤트 상세 정보 로딩 중...");
            hideBookingError();
            
            const eventRef = firebase.doc(db, COLLECTIONS.events, eventId);
            
            try {
                const docSnap = await firebase.getDoc(eventRef);
                if (!docSnap.exists()) {
                    showMessage("존재하지 않는 이벤트입니다.", 'error');
                    showEventList();
                    return;
                }

                currentEventData = { id: eventId, ...docSnap.data() };
                
                // 시간 및 상태 업데이트
                const status = getBookingStatus(currentEventData.startTime, currentEventData.endTime);
                
                document.getElementById('detail-title').textContent = currentEventData.title;
                document.getElementById('detail-description').textContent = currentEventData.description;
                document.getElementById('detail-time').textContent = `${formatKstTime(currentEventData.startTime)} ~ ${formatKstTime(currentEventData.endTime)}`;
                
                const statusEl = document.getElementById('detail-status');
                statusEl.textContent = status.status;
                statusEl.className = `kst-badge ${status.color}`;
                
                const startBookingBtn = document.getElementById('start-booking-btn');
                startBookingBtn.disabled = !status.isAvailable;
                startBookingBtn.textContent = status.isAvailable ? '예매 시작' : `예매 ${status.status}`;
                
                // 뷰 전환
                setView(views.detail);
                
            } catch (error) {
                console.error("이벤트 상세 로딩 실패:", error);
                showMessage("이벤트 정보를 불러오는 데 실패했습니다.", 'error');
            } finally {
                showLoading(false);
            }
        };

        /** 예매 시작 버튼 클릭 (유효성 검사 및 큐 진입) */
        function handleUserInfoFormSubmit(e) {
            e.preventDefault();
            
            const name = document.getElementById('input-name').value.trim();
            const studentId = document.getElementById('input-student-id').value.trim();
            const phone = document.getElementById('input-phone').value.trim();
            
            if (!currentEventData) return;
            
            // 필수 정보 체크
            if (!name || !studentId || !phone) {
                showMessage("이름, 학번, 전화번호를 모두 입력해 주세요.", 'warning');
                return;
            }

            const userData = {
                name: name,
                studentId: studentId,
                phone: phone
            };

            enterQueue(currentEventData.id, userData);
        }

        // --- 5. Queue System Core Logic ---

        /** 큐 모달 표시 */
        function showQueueModal(rank, totalUsers) {
            const queueModal = document.getElementById('queue-modal');
            if (!queueModal) return;
            document.getElementById('queue-rank').textContent = rank;
            document.getElementById('queue-behind').textContent = totalUsers > rank ? totalUsers - rank : 0;
            
            const progress = (rank / totalUsers) * 100;
            document.getElementById('queue-progress').style.width = `${100 - progress}%`;

            queueModal.classList.remove('is-hidden');
            queueModal.classList.add('flex');
        }

        /** 큐 리스너 설정 (대기열 실시간 업데이트) */
        function setupQueueListener(eventId, userData) {
            if (queueListenerUnsubscribe) queueListenerUnsubscribe(); // 기존 리스너 해제

            const queueRef = firebase.doc(db, COLLECTIONS.queueStatus, 'status');
            
            queueListenerUnsubscribe = firebase.onSnapshot(queueRef, (docSnap) => {
                if (!docSnap.exists) return;

                const statusData = docSnap.data();
                const activeUsers = statusData.active_users || {};
                const maxConcurrentUsers = statusData.max_concurrent_users || 50;

                // 1. 현재 활성 사용자 목록을 배열로 변환하고 타임스탬프로 정렬
                const activeUsersArray = Object.entries(activeUsers)
                    .map(([uid, time]) => ({ uid, time: time.toMillis ? time.toMillis() : time }))
                    .sort((a, b) => a.time - b.time);
                
                // 2. 현재 사용자 순위 계산
                const myIndex = activeUsersArray.findIndex(user => user.uid === userId);

                if (myIndex === -1) {
                    // 큐에서 빠짐 (다른 사용자가 큐를 정리했거나, 트랜잭션 성공 후 통과했거나)
                    return;
                }

                // 3. 진입 가능 여부 확인: 나의 인덱스가 동시 접속자 수보다 작다면 통과
                if (myIndex < maxConcurrentUsers) {
                    // 큐 통과! 트랜잭션 재시도 (안전한 재진입)
                    if (queueListenerUnsubscribe) {
                        queueListenerUnsubscribe(); // 리스너 해제
                        queueListenerUnsubscribe = null;
                    }
                    document.getElementById('queue-modal')?.classList.add('is-hidden');
                    showMessage("✅ 대기열을 통과했습니다! 예매창으로 이동합니다.", 'success');
                    
                    // 트랜잭션 성공 후 예매 화면으로 이동
                    setBookingUserData(userData);
                    loadEventBookingUI(eventId);
                } else {
                    // 대기열 업데이트
                    const rank = myIndex + 1;
                    const totalUsers = activeUsersArray.length;
                    showQueueModal(rank, totalUsers);
                }

            }, (error) => {
                console.error("Queue Listener Error:", error);
            });
        }

        /**
         * 3. 대기열 진입 로직 (Transaction 사용)
         */
        async function enterQueue(eventId, userData) {
            // 중복 실행 방지
            if (isBooking) return;
            isBooking = true; 
            
            showLoading(true, "대기열 진입 중...");
            hideBookingError();
            
            const adminBookingDocRef = firebase.doc(db, COLLECTIONS.adminBookings, eventId + '_' + userData.studentId);

            try {
                const bookingDocSnap = await firebase.getDoc(adminBookingDocRef);
                if (bookingDocSnap.exists()) {
                    showMessage("이미 예매된 학번입니다. 예매 내역을 확인해 주세요.", 'warning');
                    isBooking = false;
                    showLoading(false);
                    return;
                }
                
                let isPassedQueue = false;
                let isQueued = false;
                let queueRank = 0;

                await firebase.runTransaction(db, async (transaction) => {
                    const queueRef = firebase.doc(db, COLLECTIONS.queueStatus, 'status');
                    const queueDoc = await transaction.get(queueRef);

                    // 🚨 FIX: 문서가 존재하지 않는 경우 초기화 🚨
                    let statusData = queueDoc.data();
                    if (!queueDoc.exists) {
                        statusData = {
                            active_users: {},
                            max_concurrent_users: 50,
                        };
                        // Initialize the document in the transaction
                        transaction.set(queueRef, { 
                            ...statusData,
                            last_updated: firebase.serverTimestamp()
                        }, { merge: false });
                        // console.warn("Queue status document was missing and has been initialized.");
                    }
                    // 🚨 END FIX 🚨
                    
                    const activeUsers = statusData.active_users || {};
                    const maxConcurrentUsers = statusData.max_concurrent_users || 50;
                    
                    // 1. 현재 활성 사용자 목록을 배열로 변환하고 타임스탬프로 정렬
                    const activeUsersArray = Object.entries(activeUsers)
                        .map(([uid, time]) => ({ uid, time: time.toMillis ? time.toMillis() : time }))
                        .sort((a, b) => a.time - b.time);

                    // 2. 만료된 세션 정리 (10분 초과)
                    const now = Date.now();
                    const expirationTime = 10 * 60 * 1000; // 10 minutes
                    
                    let newActiveUsers = {};
                    let cleanedUsersCount = 0;

                    activeUsersArray.forEach(user => {
                        if (now - user.time < expirationTime) {
                            newActiveUsers[user.uid] = firebase.Timestamp.fromMillis(user.time);
                            cleanedUsersCount++;
                        }
                    });

                    
                    if (cleanedUsersCount < maxConcurrentUsers) {
                        // 3. 진입 허용: active_users에 자신을 등록
                        
                        // 현재 사용자 추가
                        newActiveUsers[userId] = firebase.Timestamp.fromMillis(now);
                        
                        transaction.update(queueRef, {
                            active_users: newActiveUsers,
                            last_updated: firebase.serverTimestamp()
                        });
                        
                        isPassedQueue = true;
                        
                    } else {
                        // 4. 대기열로 이동
                        isQueued = true;
                        
                        // 현재 사용자 순위 계산
                        const updatedUsersArray = Object.entries(newActiveUsers)
                            .map(([uid, time]) => ({ uid, time: time.toMillis() }))
                            .sort((a, b) => a.time - b.time);

                        queueRank = updatedUsersArray.findIndex(user => user.uid === userId);
                        if (queueRank === -1) {
                            // 자신이 큐에 없으면 맨 뒤로
                            queueRank = updatedUsersArray.length + 1;
                        } else {
                            queueRank += 1; // 0-based to 1-based
                        }
                        
                        // 큐 모달 표시 및 onSnapshot 연결
                        showQueueModal(queueRank, updatedUsersArray.length);
                        setupQueueListener(eventId, userData); 
                    }
                });

                if (isPassedQueue) {
                    // 트랜잭션 성공 후 예매 화면으로 이동
                    setBookingUserData(userData);
                    loadEventBookingUI(eventId);
                } else if (isQueued) {
                    // 큐 모달이 이미 표시됨
                    // no-op
                } else {
                    // 이 코드는 트랜잭션 실패 또는 기타 로직 오류 시 발생 가능
                    throw new Error("Queue logic failed to resolve to pass or wait state.");
                }

            } catch (error) {
                console.error("대기열 진입 중 오류 발생:", error);
                
                // Firestore permission errors or network issues
                let msg = error.message;
                if (error.code === 'permission-denied') {
                    msg = "Firestore 보안 규칙에 대기열(queue_status) 문서에 대한 Public Write 권한이 필요합니다.";
                } else if (error.code === 'aborted') {
                    msg = "동시 접속으로 인해 대기열 진입이 실패했습니다. 잠시 후 다시 시도해 주세요.";
                }

                showMessage(`대기열 진입 중 오류 발생: ${msg}`, 'error');
            } finally {
                if (!isPassedQueue && !isQueued) {
                    // 예외가 발생했거나, 예상치 못한 종료 시 로딩 해제
                    isBooking = false; 
                    showLoading(false);
                }
            }
        }

        // --- 6. Booking UI Rendering (Seats/Choices) ---

        /** 예매 UI 로드 및 렌더링 */
        async function loadEventBookingUI(eventId) {
            if (!currentEventData || currentEventData.id !== eventId) {
                // 이벤트 데이터가 없거나 ID가 일치하지 않으면 다시 로드
                await window.showEventDetail(eventId);
            }
            if (!currentEventData) return; // 로드 실패 시 종료

            const bookingContentEl = document.getElementById('booking-content');
            bookingContentEl.innerHTML = '<p class="text-center text-gray-500">예매 UI 로딩 중...</p>';
            
            try {
                if (currentEventData.type === 'seats') {
                    // 좌석형 예매 UI 렌더링
                    const seatsCol = firebase.collection(db, COLLECTIONS.events, eventId, 'seats');
                    
                    // onSnapshot으로 실시간 좌석 상태 업데이트
                    firebase.onSnapshot(firebase.query(seatsCol, firebase.orderBy('seatId')), (snapshot) => {
                        renderSeatsUI(eventId, snapshot);
                    });

                } else if (currentEventData.type === 'choices') {
                    // 선택형 예매 UI 렌더링
                    const choicesCol = firebase.collection(db, COLLECTIONS.events, eventId, 'choices');
                    
                    // onSnapshot으로 실시간 선택지 상태 업데이트
                    firebase.onSnapshot(choicesCol, (snapshot) => {
                        renderChoicesUI(eventId, snapshot);
                    });
                }
                
                setView(views.booking);
                showLoading(false);

            } catch (error) {
                console.error("예매 UI 로딩 실패:", error);
                showMessage("예매 화면을 구성하는 데 실패했습니다.", 'error');
                showEventList();
            }
        }

        /** 좌석 UI 렌더링 */
        function renderSeatsUI(eventId, snapshot) {
            const bookingContentEl = document.getElementById('booking-content');
            let seatsHtml = '';
            
            snapshot.forEach(doc => {
                const seat = doc.data();
                const seatId = doc.id;
                const isBooked = seat.isBooked;
                const isMine = seat.bookingId === bookingUserData.studentId;

                const className = isBooked 
                    ? (isMine ? 'bg-blue-500 text-white cursor-pointer hover:bg-blue-600' : 'bg-red-500 text-white cursor-not-allowed')
                    : 'bg-green-500 text-white cursor-pointer hover:bg-green-600';
                
                seatsHtml += `
                    <div class="seat ${className}" 
                         data-seat-id="${seatId}" 
                         onclick="handleSeatSelection('${eventId}', '${seatId}', ${isBooked}, ${isMine})">
                        ${seatId}
                    </div>
                `;
            });
            
            bookingContentEl.innerHTML = `
                <div class="text-center mb-4">
                    <p class="inline-block px-3 py-1 text-sm rounded-full bg-green-200 text-green-800">선택 가능</p>
                    <p class="inline-block px-3 py-1 text-sm rounded-full bg-red-200 text-red-800">예매 완료</p>
                    <p class="inline-block px-3 py-1 text-sm rounded-full bg-blue-200 text-blue-800">나의 선택</p>
                </div>
                <div class="seat-grid">${seatsHtml}</div>
                <button id="confirm-seat-booking-btn" class="w-full mt-6 p-3 rounded-lg btn-primary" onclick="confirmBooking('${eventId}', 'seat')">예매 완료</button>
                <div id="selected-seat-info" class="mt-4 text-center font-semibold text-gray-700">좌석을 선택해 주세요.</div>
            `;

            // 좌석 선택 상태 복원 (단일 선택 가정)
            const myBookedSeat = snapshot.docs.find(doc => doc.data().bookingId === bookingUserData.studentId);
            const infoEl = document.getElementById('selected-seat-info');
            if (myBookedSeat) {
                const seatId = myBookedSeat.id;
                if (infoEl) {
                    infoEl.textContent = `선택된 좌석: ${seatId}`;
                    infoEl.dataset.selectedId = seatId; // 상태 저장
                }
            } else {
                if (infoEl) infoEl.dataset.selectedId = '';
            }
        }

        /** 좌석 선택 핸들러 */
        window.handleSeatSelection = async (eventId, seatId, isBooked, isMine) => {
            if (isBooked && !isMine) {
                showMessage(`좌석 ${seatId}는 이미 예약되었습니다.`, 'warning');
                return;
            }
            if (isBooking) return; // 트랜잭션 중복 방지

            isBooking = true;
            showLoading(true, "좌석 선택 처리 중...");
            
            try {
                await firebase.runTransaction(db, async (transaction) => {
                    const seatRef = firebase.doc(db, COLLECTIONS.events, eventId, 'seats', seatId);
                    const seatDoc = await transaction.get(seatRef);
                    
                    if (!seatDoc.exists()) throw new Error("Seat not found.");

                    const seatData = seatDoc.data();
                    const infoEl = document.getElementById('selected-seat-info');
                    const currentlySelectedSeatId = infoEl?.dataset.selectedId;

                    if (seatData.isBooked && seatData.bookingId === bookingUserData.studentId) {
                        // 1. 자신의 좌석을 해제
                        transaction.update(seatRef, {
                            isBooked: false,
                            bookingId: null,
                        });
                        if (infoEl) {
                            infoEl.dataset.selectedId = '';
                            infoEl.textContent = '좌석을 선택해 주세요.';
                        }
                        showMessage(`좌석 ${seatId}가 해제되었습니다.`, 'success');

                    } else if (seatData.isBooked) {
                        // 2. 이미 다른 사람이 예약
                        throw new Error(`좌석 ${seatId}는 이미 예약되었습니다.`);

                    } else {
                        // 3. 새 좌석 선택 (기존 선택 해제 필요)

                        // 3-a. 기존 선택 좌석 해제
                        if (currentlySelectedSeatId && currentlySelectedSeatId !== seatId) {
                            const prevSeatRef = firebase.doc(db, COLLECTIONS.events, eventId, 'seats', currentlySelectedSeatId);
                            transaction.update(prevSeatRef, {
                                isBooked: false,
                                bookingId: null,
                            });
                        }

                        // 3-b. 새 좌석 예약
                        transaction.update(seatRef, {
                            isBooked: true,
                            bookingId: bookingUserData.studentId, // 학번을 임시 예매 ID로 사용
                        });
                        
                        if (infoEl) {
                            infoEl.dataset.selectedId = seatId;
                            infoEl.textContent = `선택된 좌석: ${seatId}`;
                        }
                        showMessage(`좌석 ${seatId}가 선택되었습니다.`, 'success');
                    }
                });
            } catch (error) {
                console.error("Seat selection failed:", error);
                showMessage(`좌석 선택 오류: ${error.message}`, 'error');
            } finally {
                isBooking = false;
                showLoading(false);
            }
        };


        /** 선택지 UI 렌더링 */
        function renderChoicesUI(eventId, snapshot) {
            const bookingContentEl = document.getElementById('booking-content');
            let choicesHtml = '';
            let isMineBooked = false; // 현재 사용자가 예매했는지 여부 (선택형은 단일 예매 가정)

            const choicesArray = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

            // 1. 자신의 예매 내역을 찾는다 (adminBookings에서 확인)
            const checkBooking = async () => {
                const adminBookingRef = firebase.doc(db, COLLECTIONS.adminBookings, eventId + '_' + bookingUserData.studentId);
                const snap = await firebase.getDoc(adminBookingRef);
                return snap.exists;
            }

            checkBooking().then(exists => {
                isMineBooked = exists;

                choicesArray.forEach(choice => {
                    const remaining = choice.limit - choice.count;
                    const isFull = remaining <= 0;
                    
                    const buttonText = isMineBooked ? "예매 완료됨" : (isFull ? "매진" : `예매 (${remaining}석 남음)`);
                    
                    const buttonClass = isMineBooked 
                        ? 'bg-blue-500 text-white cursor-default'
                        : (isFull ? 'bg-gray-400 text-white cursor-not-allowed' : 'bg-green-500 text-white hover:bg-green-600');

                    choicesHtml += `
                        <div class="p-4 border rounded-lg flex justify-between items-center shadow-sm bg-white">
                            <div>
                                <h4 class="font-semibold text-lg">${choice.name}</h4>
                                <p class="text-sm text-gray-600">총 정원: ${choice.limit}명</p>
                            </div>
                            <button 
                                class="p-2 rounded-lg text-sm transition-colors ${buttonClass}" 
                                data-choice-id="${choice.id}"
                                ${isFull || isMineBooked ? 'disabled' : ''}
                                onclick="handleChoiceBooking('${eventId}', '${choice.id}')">
                                ${buttonText}
                            </button>
                        </div>
                    `;
                });

                bookingContentEl.innerHTML = `
                    <p class="mb-4 text-gray-700">아래 옵션 중 하나를 선택하여 예매를 진행하세요.</p>
                    <div class="space-y-3">
                        ${choicesHtml}
                    </div>
                `;
            });
        }

        /** 선택형 예매 처리 */
        window.handleChoiceBooking = async (eventId, choiceId) => {
            if (isBooking) return;
            isBooking = true;
            showLoading(true, "예매 처리 중...");

            try {
                // 1. 중복 예매 확인은 `user-info-form` 제출 시 진행됨. 여기서는 최종 확인.
                const adminBookingDocRef = firebase.doc(db, COLLECTIONS.adminBookings, eventId + '_' + bookingUserData.studentId);
                const bookingDocSnap = await firebase.getDoc(adminBookingDocRef);
                if (bookingDocSnap.exists()) {
                    showMessage("이미 예매된 학번입니다. (중복 방지)", 'warning');
                    isBooking = false;
                    showLoading(false);
                    return;
                }
                
                await firebase.runTransaction(db, async (transaction) => {
                    const choiceRef = firebase.doc(db, COLLECTIONS.events, eventId, 'choices', choiceId);
                    const choiceDoc = await transaction.get(choiceRef);

                    if (!choiceDoc.exists()) throw new Error("Choice not found.");

                    const choiceData = choiceDoc.data();
                    if (choiceData.count >= choiceData.limit) {
                        throw new Error("매진되었습니다. 다른 옵션을 선택해 주세요.");
                    }

                    // 2. 선택지 카운트 증가
                    transaction.update(choiceRef, {
                        count: firebase.FieldValue.increment(1)
                    });

                    // 3. 예매 기록 (Admin & User)
                    const bookingData = {
                        eventId: eventId,
                        eventTitle: currentEventData.title,
                        type: 'choice',
                        bookingRefId: choiceId, // 선택지 ID 저장
                        refName: choiceData.name,
                        name: bookingUserData.name,
                        studentId: bookingUserData.studentId,
                        phone: bookingUserData.phone,
                        timestamp: firebase.serverTimestamp(),
                        userId: userId
                    };
                    
                    const bookingRef = firebase.doc(firebase.collection(db, COLLECTIONS.bookings), choiceId);
                    const adminBookingRef = firebase.doc(db, COLLECTIONS.adminBookings, eventId + '_' + bookingUserData.studentId);
                    
                    transaction.set(bookingRef, bookingData);
                    transaction.set(adminBookingRef, bookingData);
                });

                showBookingCompleteModal(bookingUserData.studentId, bookingUserData.name, '선택 완료');

            } catch (error) {
                console.error("Choice booking failed:", error);
                showMessage(`예매 실패: ${error.message}`, 'error');
            } finally {
                isBooking = false;
                showLoading(false);
            }
        };
        
        // --- 7. Booking Confirmation and Completion ---

        /** 최종 예매 완료 (좌석형 전용) */
        window.confirmBooking = async (eventId, type) => {
            if (type !== 'seat') return;
            
            const infoEl = document.getElementById('selected-seat-info');
            const selectedSeatId = infoEl?.dataset.selectedId;

            if (!selectedSeatId) {
                showMessage("예약할 좌석을 선택해 주세요.", 'warning');
                return;
            }
            if (isBooking) return;

            isBooking = true;
            showLoading(true, `좌석 ${selectedSeatId} 최종 예매 중...`);
            
            try {
                // 1. 중복 예매 확인
                const adminBookingDocRef = firebase.doc(db, COLLECTIONS.adminBookings, eventId + '_' + bookingUserData.studentId);
                const bookingDocSnap = await firebase.getDoc(adminBookingDocRef);
                if (bookingDocSnap.exists()) {
                    showMessage("이미 예매된 학번입니다. (중복 방지)", 'warning');
                    isBooking = false;
                    showLoading(false);
                    return;
                }
                
                await firebase.runTransaction(db, async (transaction) => {
                    const seatRef = firebase.doc(db, COLLECTIONS.events, eventId, 'seats', selectedSeatId);
                    const seatDoc = await transaction.get(seatRef);

                    if (!seatDoc.exists()) throw new Error("Seat not found.");
                    const seatData = seatDoc.data();
                    
                    // 2. 좌석이 아직 나의 임시 예약 상태인지 확인 (트랜잭션 도중 상태 변경 방지)
                    if (seatData.isBooked && seatData.bookingId !== bookingUserData.studentId) {
                         throw new Error(`좌석 ${selectedSeatId}는 이미 다른 사람에 의해 예약되었습니다.`);
                    }
                    if (!seatData.isBooked) {
                        throw new Error(`좌석 ${selectedSeatId}가 선택되어 있지 않습니다. 다시 선택해주세요.`);
                    }

                    // 3. 예매 기록 (Admin & User)
                    const bookingData = {
                        eventId: eventId,
                        eventTitle: currentEventData.title,
                        type: 'seat',
                        bookingRefId: selectedSeatId, // 좌석 ID 저장
                        refName: selectedSeatId,
                        name: bookingUserData.name,
                        studentId: bookingUserData.studentId,
                        phone: bookingUserData.phone,
                        timestamp: firebase.serverTimestamp(),
                        userId: userId
                    };
                    
                    const bookingRef = firebase.doc(firebase.collection(db, COLLECTIONS.bookings), selectedSeatId);
                    const adminBookingRef = firebase.doc(db, COLLECTIONS.adminBookings, eventId + '_' + bookingUserData.studentId);
                    
                    transaction.set(bookingRef, bookingData);
                    transaction.set(adminBookingRef, bookingData);
                });

                showBookingCompleteModal(bookingUserData.studentId, bookingUserData.name, selectedSeatId);

            } catch (error) {
                console.error("Seat booking confirmation failed:", error);
                showMessage(`예매 실패: ${error.message}`, 'error');
            } finally {
                isBooking = false;
                showLoading(false);
            }
        };

        /** 예매 완료 모달 표시 */
        function showBookingCompleteModal(studentId, name, bookingRef) {
            const modalEl = document.getElementById('complete-modal');
            if (!modalEl) return;
            document.getElementById('complete-student-id').textContent = studentId;
            document.getElementById('complete-name').textContent = name;
            document.getElementById('complete-booking-number').textContent = bookingRef;
            
            modalEl.classList.remove('is-hidden');
        }
        window.showBookingCompleteModal = showBookingCompleteModal;


        // --- 8. My Booking Check and Cancel ---

        /** 예매 내역 조회 */
        function handleCheckBookingFormSubmit(e) {
            e.preventDefault();
            const studentId = document.getElementById('check-student-id').value.trim();
            const bookingRefId = document.getElementById('check-booking-number').value.trim(); // 좌석ID 또는 선택지ID
            const resultEl = document.getElementById('checked-booking-result');
            const errorEl = document.getElementById('check-error-msg');
            
            resultEl?.classList.add('hidden');
            errorEl?.classList.add('hidden');
            showLoading(true, "예매 내역 조회 중...");

            checkBooking(studentId, bookingRefId, resultEl, errorEl);
        }

        async function checkBooking(studentId, bookingRefId, resultEl, errorEl) {
            try {
                // 1. 유저의 개인 bookings 컬렉션에서 조회
                if (!COLLECTIONS.bookings) {
                    errorEl.textContent = "사용자 인증이 완료되지 않았습니다. 잠시 후 다시 시도해주세요.";
                    errorEl.classList.remove('hidden');
                    return;
                }

                const bookingQuery = firebase.query(
                    firebase.collection(db, COLLECTIONS.bookings), 
                    firebase.where('studentId', '==', studentId), 
                    firebase.where('bookingRefId', '==', bookingRefId),
                    firebase.limit(1)
                );
                const querySnapshot = await firebase.getDocs(bookingQuery);
                
                if (querySnapshot.empty) {
                    errorEl.textContent = "일치하는 예매 내역이 없습니다. 학번과 예매번호를 확인해 주세요.";
                    errorEl.classList.remove('hidden');
                    return;
                }

                const bookingDoc = querySnapshot.docs[0];
                const booking = bookingDoc.data();
                const bookingId = bookingDoc.id;
                
                const eventRef = firebase.doc(db, COLLECTIONS.events, booking.eventId);
                const eventSnap = await firebase.getDoc(eventRef);
                const eventTitle = eventSnap.exists() ? eventSnap.data().title : '알 수 없는 이벤트';

                if (resultEl) {
                    resultEl.innerHTML = `
                        <p class="font-bold text-lg text-blue-700 mb-2">예매 내역 확인됨</p>
                        <p><strong>이벤트:</strong> ${eventTitle}</p>
                        <p><strong>예매자:</strong> ${booking.name} (${booking.studentId})</p>
                        <p><strong>선택 항목:</strong> ${booking.refName} (${booking.type === 'seat' ? '좌석형' : '선택형'})</p>
                        <p class="text-xs text-gray-500">예매 시각: ${formatKstTime(booking.timestamp)}</p>
                        <button onclick="cancelBooking('${booking.eventId}', '${booking.type}', '${booking.bookingRefId}', '${booking.studentId}')" 
                                class="w-full mt-4 p-2 rounded-lg bg-red-600 text-white hover:bg-red-700 transition-colors">
                            예매 취소
                        </button>
                    `;
                    resultEl.classList.remove('hidden');
                }

            } catch (error) {
                console.error("Booking check failed:", error);
                if (errorEl) {
                    errorEl.textContent = `조회 실패: ${error.message}`;
                    errorEl.classList.remove('hidden');
                }
            } finally {
                showLoading(false);
            }
        }


        /** 예매 취소 (Transaction 사용) */
        window.cancelBooking = async (eventId, type, bookingRefId, studentId) => {
            if (isBooking) return;
            isBooking = true;
            
            showLoading(true, "예매 취소 처리 중...");
            
            try {
                await firebase.runTransaction(db, async (transaction) => {
                    // 1. Admin Bookings 삭제 (가장 먼저)
                    const adminBookingRef = firebase.doc(db, COLLECTIONS.adminBookings, eventId + '_' + studentId);
                    transaction.delete(adminBookingRef);
                    
                    // 2. User Bookings 삭제 (COLLECTIONS.bookings가 null이 아닌지 확인)
                    if (COLLECTIONS.bookings) {
                        const userBookingRef = firebase.doc(firebase.collection(db, COLLECTIONS.bookings), bookingRefId);
                        transaction.delete(userBookingRef);
                    }


                    // 3. 이벤트 상태 복구
                    if (type === 'choice') {
                        // 선택형: count 감소 (bookingRefId는 choice ID)
                        const choiceRef = firebase.doc(db, COLLECTIONS.events, eventId, 'choices', bookingRefId);
                        transaction.update(choiceRef, { 
                            count: firebase.FieldValue.increment(-1)
                        });
                        
                    } else if (type === 'seat') {
                        // 좌석형: isBooked 해제 (bookingRefId는 seat ID)
                        const seatRef = firebase.doc(db, COLLECTIONS.events, eventId, 'seats', bookingRefId);
                        transaction.update(seatRef, { 
                            isBooked: false,
                            bookingId: null,
                        });
                    }
                });
                
                showMessage("✅ 예매가 성공적으로 취소되었습니다.", 'success');
                // UI 업데이트
                document.getElementById('checked-booking-result')?.classList.add('hidden');
                document.getElementById('check-booking-form')?.reset();
                
            } catch (error) {
                console.error("Cancellation Error:", error);
                showMessage(`취소 실패: ${error.message}`, 'error');
            } finally {
                isBooking = false;
                showLoading(false);
            }
        };

        // --- 9. Admin Functions (CRUD, Delete Booking) ---

        /** 관리자 모드 이벤트 목록 로드 (onSnapshot으로 실시간) */
        function loadAdminEvents() {
            const eventsCol = firebase.collection(db, COLLECTIONS.events);
            const adminEventListEl = document.getElementById('admin-event-list');
            
            if (!adminEventListEl) return;

            // 큐 리스너 해제 (관리자 모드는 별도 리스너 사용)
            if (queueListenerUnsubscribe) {
                queueListenerUnsubscribe();
                queueListenerUnsubscribe = null;
            }

            firebase.onSnapshot(eventsCol, (snapshot) => {
                adminEventListEl.innerHTML = '';
                if (snapshot.empty) {
                    adminEventListEl.innerHTML = '<p class="text-center text-gray-500">등록된 이벤트가 없습니다.</p>';
                    return;
                }

                snapshot.forEach(doc => {
                    const event = doc.data();
                    const eventId = doc.id;
                    const kstStart = formatKstTime(event.startTime);
                    
                    const item = `
                        <div class="p-4 border rounded-lg bg-white flex justify-between items-center shadow-sm">
                            <div>
                                <p class="font-semibold text-lg text-gray-800">${event.title} <span class="text-sm text-gray-500">(${event.type === 'seats' ? '좌석형' : '선택형'})</span></p>
                                <p class="text-xs text-gray-500">ID: ${eventId}</p>
                                <p class="text-sm text-blue-600">시작: ${kstStart}</p>
                            </div>
                            <div class="space-x-2 flex items-center">
                                <button onclick="startEditEvent('${eventId}')" class="p-2 text-sm bg-yellow-500 text-white rounded hover:bg-yellow-600">수정</button>
                                <button onclick="deleteEvent('${eventId}')" class="p-2 text-sm bg-red-500 text-white rounded hover:bg-red-600">삭제</button>
                                <button onclick="showAdminBookingSearchModal('${eventId}', '${event.title}')" class="p-2 text-sm bg-indigo-500 text-white rounded hover:bg-indigo-600">예매 삭제</button>
                            </div>
                        </div>
                    `;
                    adminEventListEl.insertAdjacentHTML('beforeend', item);
                });
            }, (error) => {
                console.error("관리자 이벤트 로딩 실패:", error);
                adminEventListEl.innerHTML = '<p class="text-center text-red-500">이벤트 목록을 불러오는 데 실패했습니다.</p>';
            });
        }
        
        /** 폼 초기화 */
        window.resetAdminForm = function() {
            editingEventId = null;
            document.getElementById('create-event-form')?.reset();
            document.getElementById('admin-form-mode').textContent = "새 이벤트 생성 모드";
            document.getElementById('create-event-button').textContent = "이벤트 생성";
            document.getElementById('admin-error-msg')?.classList.add('hidden');
            // 선택형 UI 기본값으로 재설정
            const adminTypeEl = document.getElementById('admin-type');
            if (adminTypeEl) {
                adminTypeEl.value = 'choices';
                adminTypeEl.dispatchEvent(new Event('change'));
            }
        }

        /** 이벤트 수정 시작 */
        window.startEditEvent = async function(eventId) {
            showLoading(true, "이벤트 데이터 로딩 중...");
            try {
                const eventRef = firebase.doc(db, COLLECTIONS.events, eventId);
                const eventSnap = await firebase.getDoc(eventRef);

                if (!eventSnap.exists()) {
                    showMessage("수정할 이벤트를 찾을 수 없습니다.", 'error');
                    return;
                }

                const event = eventSnap.data();
                editingEventId = eventId;
                
                document.getElementById('admin-form-mode').textContent = `이벤트 수정 모드 (ID: ${eventId})`;
                document.getElementById('create-event-button').textContent = "수정 완료";
                
                document.getElementById('admin-title').value = event.title;
                document.getElementById('admin-description').value = event.description;
                
                // Firestore Timestamp to datetime-local format
                const startTimeISO = event.startTime.toDate().toISOString().slice(0, 16);
                const endTimeISO = event.endTime.toDate().toISOString().slice(0, 16);
                document.getElementById('admin-start-time').value = startTimeISO;
                document.getElementById('admin-end-time').value = endTimeISO;
                
                const adminTypeEl = document.getElementById('admin-type');
                if (adminTypeEl) {
                    adminTypeEl.value = event.type;
                    adminTypeEl.dispatchEvent(new Event('change')); // UI 업데이트 트리거
                }


                const configEl = document.getElementById('admin-type-config');
                if (!configEl) return;

                if (event.type === 'seats') {
                    // 좌석형은 수정 불가 (좌석 데이터는 수동 수정 필요)
                    configEl.innerHTML = `<p class="text-red-500 font-bold">좌석 정보는 생성 후 Firestore 콘솔에서 수동으로 수정해야 합니다.</p>`;
                } else if (event.type === 'choices') {
                    const choicesCol = firebase.collection(db, COLLECTIONS.events, eventId, 'choices');
                    const choicesSnap = await firebase.getDocs(choicesCol);
                    
                    const container = document.getElementById('choices-container');
                    if (container) container.innerHTML = '';
                    
                    choicesSnap.forEach(doc => {
                        const choice = doc.data();
                        const choiceId = doc.id;
                        if (container) {
                             container.insertAdjacentHTML('beforeend', `
                                <div class="flex gap-2 choice-option" data-choice-id="${choiceId}">
                                    <input type="text" placeholder="옵션 이름" class="flex-grow p-2 border rounded choice-name" value="${choice.name}">
                                    <input type="number" placeholder="정원" min="1" class="w-20 p-2 border rounded choice-limit" value="${choice.limit}">
                                    <p class="w-20 p-2 text-sm text-gray-600">예매 수: ${choice.count}</p>
                                    <button type="button" onclick="removeChoiceOption(this, '${choiceId}')" class="text-red-500">X</button>
                                </div>
                            `);
                        }
                    });
                }
                
                // 뷰 이동
                document.getElementById('admin-view')?.scrollIntoView({ behavior: 'smooth' });

            } catch (error) {
                console.error("Edit load failed:", error);
                showMessage(`수정 정보 로드 실패: ${error.message}`, 'error');
            } finally {
                showLoading(false);
            }
        }

        /** 이벤트 삭제 */
        window.deleteEvent = function(eventId) {
            showGlobalModal(true, "🚨 이벤트 삭제 확인", 
                `<p>정말로 이벤트 ID <strong>${eventId}</strong>를 삭제하시겠습니까? 모든 예매 내역과 하위 데이터(좌석/선택지)가 영구 삭제됩니다.</p>`,
                `<button onclick="confirmDeleteEvent('${eventId}')" class="p-2 rounded bg-red-600 text-white hover:bg-red-700">영구 삭제</button>
                 <button onclick="showGlobalModal(false)" class="p-2 rounded bg-gray-300 ml-2">취소</button>`
            );
        }

        /** 이벤트 삭제 확정 */
        window.confirmDeleteEvent = async function(eventId) {
            showGlobalModal(false);
            showLoading(true, "이벤트 및 모든 데이터 삭제 중...");

            try {
                const eventRef = firebase.doc(db, COLLECTIONS.events, eventId);
                const batch = firebase.writeBatch(db); // For deleting all records

                // 1. 하위 컬렉션 삭제 (선택지 및 좌석)
                
                const deleteSubcollection = async (subcollectionPath) => {
                    const colRef = firebase.collection(db, COLLECTIONS.events, eventId, subcollectionPath);
                    const snapshot = await firebase.getDocs(colRef);
                    snapshot.docs.forEach(doc => batch.delete(doc.ref));
                };

                await deleteSubcollection('choices');
                await deleteSubcollection('seats');

                // 2. 예매 내역 삭제 (adminBookings)
                
                // Delete Admin Bookings related to this event
                const adminBookingsQuery = firebase.query(firebase.collection(db, COLLECTIONS.adminBookings), firebase.where('eventId', '==', eventId));
                const adminBookingsSnap = await firebase.getDocs(adminBookingsQuery);
                adminBookingsSnap.docs.forEach(doc => batch.delete(doc.ref));

                // 3. 메인 이벤트 문서 삭제
                batch.delete(eventRef);

                await batch.commit();

                showMessage(`✅ 이벤트 ID ${eventId}가 영구 삭제되었습니다.`, 'success');
                resetAdminForm(); // 폼 초기화
                
            } catch (error) {
                console.error("Deletion failed:", error);
                showMessage(`이벤트 삭제 실패: ${error.message}`, 'error');
            } finally {
                showLoading(false);
            }
        }
        
        // --- Admin Form Logic ---
        
        /** 이벤트 생성/수정 제출 핸들러 */
        window.handleCreateEventFormSubmit = async function(e) {
            e.preventDefault();

            const title = document.getElementById('admin-title').value.trim();
            const description = document.getElementById('admin-description').value.trim();
            const startTimeLocal = document.getElementById('admin-start-time').value;
            const endTimeLocal = document.getElementById('admin-end-time').value;
            const type = document.getElementById('admin-type').value;

            const startTime = getKstTimestamp(startTimeLocal);
            const endTime = getKstTimestamp(endTimeLocal);
            const errorEl = document.getElementById('admin-error-msg');
            errorEl.classList.add('hidden');
            
            if (!title || !description || !startTime || !endTime) {
                errorEl.textContent = "모든 필수 필드를 채워주세요.";
                errorEl.classList.remove('hidden');
                return;
            }

            if (startTime.seconds >= endTime.seconds) {
                errorEl.textContent = "예매 종료 시각은 시작 시각보다 늦어야 합니다.";
                errorEl.classList.remove('hidden');
                return;
            }

            showLoading(true, editingEventId ? "이벤트 수정 중..." : "이벤트 생성 중...");

            try {
                const eventRef = editingEventId 
                    ? firebase.doc(db, COLLECTIONS.events, editingEventId)
                    : firebase.doc(firebase.collection(db, COLLECTIONS.events));
                
                const eventData = {
                    title,
                    description,
                    startTime,
                    endTime,
                    type,
                    updatedAt: firebase.serverTimestamp()
                };

                // 1. 이벤트 문서 생성/업데이트
                await firebase.setDoc(eventRef, eventData, { merge: true });
                const currentEventId = eventRef.id;

                // 2. 하위 컬렉션 처리 (Seats or Choices)
                if (!editingEventId) { // 새 이벤트 생성 시에만 초기 데이터 설정
                    if (type === 'seats') {
                        // 기본 20개 좌석 생성 (A1~A10, B1~B10)
                        const batch = firebase.writeBatch(db);
                        for (let i = 1; i <= 10; i++) {
                            batch.set(firebase.doc(db, COLLECTIONS.events, currentEventId, 'seats', `A${i}`), { seatId: `A${i}`, isBooked: false, bookingId: null });
                            batch.set(firebase.doc(db, COLLECTIONS.events, currentEventId, 'seats', `B${i}`), { seatId: `B${i}`, isBooked: false, bookingId: null });
                        }
                        await batch.commit();
                    } else if (type === 'choices') {
                        // 선택형 옵션 처리
                        const choiceOptions = document.querySelectorAll('#choices-container .choice-option');
                        if (choiceOptions.length === 0) {
                            throw new Error("선택형 이벤트는 최소 하나의 옵션이 필요합니다.");
                        }
                        
                        const batch = firebase.writeBatch(db);
                        choiceOptions.forEach((option, index) => {
                            const name = option.querySelector('.choice-name').value.trim() || `옵션 ${index + 1}`;
                            const limit = parseInt(option.querySelector('.choice-limit').value, 10) || 10;
                            const choiceId = option.dataset.choiceId || firebase.doc(firebase.collection(db, COLLECTIONS.events, currentEventId, 'choices')).id;
                            
                            batch.set(firebase.doc(db, COLLECTIONS.events, currentEventId, 'choices', choiceId), { 
                                name, 
                                limit, 
                                count: 0,
                                createdAt: firebase.serverTimestamp()
                            });
                        });
                        await batch.commit();
                    }
                } else if (type === 'choices') {
                     // 수정 모드: 선택형 옵션 업데이트
                    const choiceOptions = document.querySelectorAll('#choices-container .choice-option');
                    
                    const batch = firebase.writeBatch(db);
                    choiceOptions.forEach((option, index) => {
                        const name = option.querySelector('.choice-name').value.trim() || `옵션 ${index + 1}`;
                        const limit = parseInt(option.querySelector('.choice-limit').value, 10) || 10;
                        const choiceId = option.dataset.choiceId; // 기존 ID 사용

                        if (choiceId) {
                            batch.update(firebase.doc(db, COLLECTIONS.events, currentEventId, 'choices', choiceId), { 
                                name, 
                                limit, 
                                updatedAt: firebase.serverTimestamp()
                            });
                        }
                        // 새로 추가된 옵션은 현재 로직에서는 처리하지 않음 (생성 모드와 통합 필요)
                    });
                    await batch.commit();
                }

                showMessage(`✅ 이벤트 ${editingEventId ? '수정' : '생성'} 완료: ${title}`, 'success');
                resetAdminForm();
                
            } catch (error) {
                console.error("Event CRUD failed:", error);
                errorEl.textContent = `처리 실패: ${error.message}`;
                errorEl.classList.remove('hidden');
            } finally {
                showLoading(false);
            }
        }
        
        /** 선택형 옵션 UI 추가 */
        window.addChoiceOption = function() {
            const container = document.getElementById('choices-container');
            if (container) {
                const newId = crypto.randomUUID();
                container.insertAdjacentHTML('beforeend', `
                    <div class="flex gap-2 choice-option" data-choice-id="${newId}">
                        <input type="text" placeholder="옵션 이름" class="flex-grow p-2 border rounded choice-name">
                        <input type="number" placeholder="정원" min="1" class="w-20 p-2 border rounded choice-limit" value="10">
                        <p class="w-20 p-2 text-sm text-gray-600 hidden">예매 수: 0</p>
                        <button type="button" onclick="removeChoiceOption(this, '${newId}')" class="text-red-500">X</button>
                    </div>
                `);
            }
        }

        /** 관리자용 선택형 옵션 제거 (수정 모드) */
        window.removeChoiceOption = function(button, choiceId) {
            const optionEl = button.closest('.choice-option');
            if (!editingEventId || !choiceId || optionEl.querySelector('.choice-limit').value === '') {
                // 생성 모드에서 새로 만든 옵션이거나, 수정 모드지만 아직 DB에 저장되지 않은 옵션
                optionEl.remove();
                return;
            }
            
            showGlobalModal(true, "옵션 삭제 확인", 
                `<p>이 옵션(${choiceId})을 삭제하면 예매자 카운트도 초기화됩니다. 계속하시겠습니까?</p>`,
                `<button onclick="confirmRemoveChoiceOption('${choiceId}')" class="p-2 rounded bg-red-600 text-white hover:bg-red-700">옵션 삭제</button>
                 <button onclick="showGlobalModal(false)" class="p-2 rounded bg-gray-300 ml-2">취소</button>`
            );
        }
        
        /** 선택형 옵션 UI 변경 시 핸들러 */
        window.handleAdminTypeChange = function(selectElement) {
            const configEl = document.getElementById('admin-type-config');
            if (!configEl) return;
            
            if (selectElement.value === 'seats') {
                configEl.innerHTML = `
                    <p class="text-sm text-gray-600">좌석형 이벤트는 생성 시 기본 좌석(A1~B10, 총 20개)이 자동으로 생성됩니다. 좌석 레이아웃 및 추가/수정은 Firestore 콘솔을 통해 직접 진행해야 합니다.</p>
                `;
            } else if (selectElement.value === 'choices') {
                configEl.innerHTML = `
                    <div id="choices-container" class="space-y-3">
                        <!-- Options will be added here -->
                    </div>
                    <button type="button" onclick="addChoiceOption()" class="mt-3 p-2 rounded-lg bg-gray-200 text-gray-700 hover:bg-gray-300 w-full font-semibold">
                        + 옵션 추가
                    </button>
                `;
                // 수정 모드가 아니라면 기본 옵션 1개 추가
                if (!editingEventId) {
                    addChoiceOption();
                }
            }
        };


        /** 선택형 옵션 삭제 확정 */
        window.confirmRemoveChoiceOption = async function(choiceId) {
            showGlobalModal(false);
            showLoading(true, "옵션 삭제 중...");

            try {
                const choiceRef = firebase.doc(db, COLLECTIONS.events, editingEventId, 'choices', choiceId);
                await firebase.deleteDoc(choiceRef);
                
                // DOM에서 제거
                document.querySelector(`.choice-option[data-choice-id="${choiceId}"]`)?.remove();
                
                showMessage(`✅ 옵션 ${choiceId}가 삭제되었습니다.`, 'success');
            } catch (error) {
                console.error("Option deletion failed:", error);
                showMessage(`옵션 삭제 실패: ${error.message}`, 'error');
            } finally {
                showLoading(false);
            }
        }

        /** 예매 내역 강제 삭제 모달 표시 */
        window.showAdminBookingSearchModal = function(eventId, eventTitle) {
            showGlobalModal(true, `[${eventTitle}] 예매 강제 삭제`,
                `<p class="mb-4">강제 삭제할 예매자의 학번을 입력하세요. 해당 예매(adminBookings)가 삭제되고, 좌석/선택지 카운트가 복구됩니다.</p>
                 <input type="text" id="admin-delete-student-id" placeholder="예매자 학번" class="w-full p-2 border rounded-lg mb-4">
                 <p id="admin-delete-error" class="text-red-500 text-sm hidden mb-2"></p>`,
                `<button onclick="adminSearchBooking('${eventId}')" class="p-2 rounded bg-indigo-600 text-white hover:bg-indigo-700">조회 및 확인</button>
                 <button onclick="showGlobalModal(false)" class="p-2 rounded bg-gray-300 ml-2">취소</button>`,
                'max-w-xl'
            );
        }

        /** 관리자 예매 내역 조회 */
        window.adminSearchBooking = async function(eventId) {
            const studentId = document.getElementById('admin-delete-student-id')?.value.trim();
            const errorEl = document.getElementById('admin-delete-error');
            errorEl?.classList.add('hidden');
            if (!studentId) { if (errorEl) { errorEl.textContent = "학번을 입력하세요."; errorEl.classList.remove('hidden'); } return; }

            showLoading(true, "예매 내역 조회 중...");

            try {
                const adminBookingRef = firebase.doc(db, COLLECTIONS.adminBookings, eventId + '_' + studentId);
                const snap = await firebase.getDoc(adminBookingRef);

                if (!snap.exists()) {
                    if (errorEl) { errorEl.textContent = "일치하는 예매 내역(adminBookings)이 없습니다."; errorEl.classList.remove('hidden'); }
                    return;
                }

                const booking = snap.data();
                const bookingId = snap.id; // eventId_studentId
                
                showGlobalModal(true, "🚨 예매 강제 삭제 확인",
                    `<div class="bg-red-50 p-4 rounded-lg text-left">
                        <p class="font-bold mb-2">다음 예매를 강제로 삭제합니다:</p>
                        <p><strong>이벤트:</strong> ${booking.eventTitle}</p>
                        <p><strong>예매자:</strong> ${booking.name} (${booking.studentId})</p>
                        <p><strong>선택 항목:</strong> ${booking.refName} (${booking.type === 'seat' ? '좌석형' : '선택형'})</p>
                        <p class="text-xs text-gray-500">DB ID: ${bookingId}</p>
                    </div>`,
                    `<button onclick="adminDeleteConfirmed('${eventId}', '${booking.type}', '${booking.bookingRefId}', '${booking.studentId}', '${bookingId}')" 
                            class="p-2 rounded bg-red-600 text-white hover:bg-red-700 mt-4">강제 삭제 실행</button>
                     <button onclick="showGlobalModal(false)" class="p-2 rounded bg-gray-300 ml-2 mt-4">취소</button>`,
                    'max-w-xl'
                );

            } catch (error) {
                console.error("Admin Search Error:", error);
                if (errorEl) { errorEl.textContent = `조회 실패: ${error.message}`; errorEl.classList.remove('hidden'); }
            } finally {
                showLoading(false);
            }
        }

        /** 관리자 예매 내역 강제 삭제 확정 */
        window.adminDeleteConfirmed = async function(eventId, type, bookingRefId, studentId, bookingId) {
            showGlobalModal(false);
            showLoading(true, "예매 강제 삭제 및 데이터 복구 중...");

            try {
                await firebase.runTransaction(db, async (transaction) => {
                    // 1. Admin Bookings 삭제
                    const adminBookingRef = firebase.doc(db, COLLECTIONS.adminBookings, bookingId);
                    transaction.delete(adminBookingRef);
                    
                    // 3. 이벤트 상태 복구
                    if (type === 'choice') {
                        // 선택형: count 감소 (bookingRefId는 choice ID)
                        const choiceRef = firebase.doc(db, COLLECTIONS.events, eventId, 'choices', bookingRefId);
                        transaction.update(choiceRef, { 
                            count: firebase.FieldValue.increment(-1)
                        });
                        
                    } else if (type === 'seat') {
                        // 좌석형: isBooked 해제 (bookingRefId는 seat doc ID)
                        const seatRef = firebase.doc(db, COLLECTIONS.events, eventId, 'seats', bookingRefId);
                        transaction.update(seatRef, { 
                            isBooked: false,
                            bookingId: null,
                        });
                    }
                });
                
                showMessage(`✅ 예매 내역(ID: ${bookingId})이 성공적으로 삭제되었습니다.`, 'success');
                // Refresh modal content
                document.getElementById('global-modal')?.classList.add('is-hidden');
                
            } catch (error) {
                console.error("Admin Delete Error:", error);
                showMessage(`삭제 실패: ${error.message}`, 'error');
            } finally {
                showLoading(false);
            }
        }
        
        // --- Event Listener Setup ---

        /** 이벤트 목록 실시간 로드 */
        function setupEventListListener() {
            const eventsCol = firebase.collection(db, COLLECTIONS.events);
            const eventListEl = document.getElementById('event-list');
            
            if (!eventListEl) return;
            
            firebase.onSnapshot(eventsCol, (snapshot) => {
                eventListEl.innerHTML = '';
                if (snapshot.empty) {
                    eventListEl.innerHTML = '<p class="text-center text-gray-500 p-8">현재 등록된 이벤트가 없습니다.</p>';
                    return;
                }

                snapshot.forEach(doc => {
                    const event = doc.data();
                    const eventId = doc.id;
                    const kstStart = formatKstTime(event.startTime);
                    const status = getBookingStatus(event.startTime, event.endTime);
                    
                    const card = `
                        <div class="kst-card p-6 flex flex-col justify-between" onclick="showEventDetail('${eventId}')">
                            <div>
                                <h3 class="text-xl font-bold text-gray-900 mb-2">${event.title}</h3>
                                <p class="text-sm text-gray-600 mb-3">${event.description.substring(0, 50)}${event.description.length > 50 ? '...' : ''}</p>
                            </div>
                            <div>
                                <p class="text-xs text-blue-500 mb-2">예매 시간: ${kstStart}</p>
                                <span class="kst-badge ${status.color}">${status.status}</span>
                            </div>
                        </div>
                    `;
                    eventListEl.insertAdjacentHTML('beforeend', card);
                });
            }, (error) => {
                console.error("Event List Loading Failed:", error);
                eventListEl.innerHTML = '<p class="text-center text-red-500 p-8">이벤트 목록을 불러오는 데 실패했습니다.</p>';
            });
        }

        // --- 10. INITIALIZATION ---
        
        /** Firebase 및 DOM 이벤트 리스너 초기화 */
        async function initializeFirebase() {
            // 1. DOM 요소 캐싱
            views = {
                list: document.getElementById('event-list-view'),
                detail: document.getElementById('detail-view'),
                booking: document.getElementById('booking-view'),
                admin: document.getElementById('admin-view')
            };

            // 2. Firebase 초기화
            try {
                const app = firebase.initializeApp(firebaseConfig);
                db = firebase.getFirestore(app);
                auth = firebase.getAuth(app);
            } catch (error) {
                console.error("Firebase Initialization Failed:", error);
                showMessage("Firebase 초기화에 실패했습니다. 환경 설정을 확인하세요.", 'error', 10000);
                return;
            }

            // 3. 인증 상태 확인 및 사용자 ID 설정
            await new Promise(resolve => {
                const unsubscribe = firebase.onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                    } else if (initialAuthToken) {
                        try {
                            const cred = await firebase.signInWithCustomToken(auth, initialAuthToken);
                            userId = cred.user.uid;
                        } catch (error) {
                            console.error("Custom Token Sign-In Failed:", error);
                            await firebase.signInAnonymously(auth);
                            userId = auth.currentUser.uid;
                        }
                    } else {
                        await firebase.signInAnonymously(auth);
                        userId = auth.currentUser.uid;
                    }

                    // 사용자 ID에 따라 COLLECTIONS.bookings 경로 설정
                    COLLECTIONS.bookings = 'artifacts/' + appId + '/users/' + userId + '/bookings';
                    
                    unsubscribe();
                    resolve();
                });
            });
            
            // 4. 이벤트 리스너 설정 (DOM이 준비되었으므로 안전하게 추가)
            document.getElementById('user-info-form')?.addEventListener('submit', handleUserInfoFormSubmit);
            document.getElementById('check-booking-form')?.addEventListener('submit', handleCheckBookingFormSubmit);
            document.getElementById('create-event-form')?.addEventListener('submit', handleCreateEventFormSubmit);
            document.getElementById('admin-type')?.addEventListener('change', (e) => handleAdminTypeChange(e.target));


            // 5. 초기 뷰 설정 및 이벤트 리스너 시작
            setupEventListListener();
            showEventList(); // 기본 뷰는 이벤트 목록
        }

        window.addEventListener('load', initializeFirebase);
        
    </script>
</head>
<body class="min-h-screen">
    <div id="app" class="max-w-4xl mx-auto p-4 md:p-8">
        <!-- Header -->
        <header class="flex justify-between items-center py-4 mb-8 border-b-4 border-emerald-500">
            <h1 class="text-3xl font-extrabold text-gray-800">KST 예매 시스템</h1>
            <div class="space-x-2">
                <button onclick="window.toggleAdminView()" class="px-3 py-1 text-sm rounded bg-gray-200 text-gray-700 hover:bg-gray-300">관리자 모드</button>
            </div>
        </header>

        <!-- 1. Event List View -->
        <div id="event-list-view" class="hidden">
            <h2 class="text-2xl font-semibold mb-6 text-gray-700">진행 중인 이벤트</h2>
            <div id="event-list" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                <!-- Event cards will be inserted here by JavaScript -->
                <p class="text-center text-gray-500 p-8">이벤트 목록 로딩 중...</p>
            </div>
            
            <!-- My Booking Check Section -->
            <div class="mt-10 p-6 kst-card">
                <h3 class="text-xl font-semibold mb-4 text-gray-700">나의 예매 내역 조회 및 취소</h3>
                <form id="check-booking-form" class="space-y-4">
                    <input type="text" id="check-student-id" placeholder="학번 (예: 20231234)" required class="w-full p-3 border rounded-lg focus:ring-emerald-500 focus:border-emerald-500">
                    <input type="text" id="check-booking-number" placeholder="예매 번호 (좌석명 또는 옵션 ID)" required class="w-full p-3 border rounded-lg focus:ring-emerald-500 focus:border-emerald-500">
                    <p id="check-error-msg" class="text-red-500 text-sm hidden"></p>
                    <button type="submit" class="w-full p-3 rounded-lg bg-indigo-600 text-white font-bold hover:bg-indigo-700">예매 내역 조회</button>
                </form>
                <div id="checked-booking-result" class="hidden mt-4 p-4 border-t border-gray-200">
                    <!-- Booking result and cancel button will be inserted here -->
                </div>
            </div>
        </div>

        <!-- 2. Event Detail and User Info View -->
        <div id="detail-view" class="hidden max-w-xl mx-auto kst-card p-6">
            <h2 id="detail-title" class="text-3xl font-bold mb-4 text-gray-800">이벤트 제목</h2>
            <p id="detail-description" class="text-gray-600 mb-4">이벤트 상세 설명</p>
            <div class="flex justify-between items-center mb-6 border-b pb-4">
                <p class="text-sm font-medium text-gray-700">예매 기간: <span id="detail-time" class="text-blue-600 font-semibold"></span></p>
                <span id="detail-status" class="kst-badge bg-gray-500">상태</span>
            </div>
            
            <h3 class="text-xl font-semibold mb-4 text-gray-700">예매자 정보 입력</h3>
            <form id="user-info-form" class="space-y-4">
                <input type="text" id="input-name" placeholder="이름" required class="w-full p-3 border rounded-lg focus:ring-emerald-500 focus:border-emerald-500">
                <input type="text" id="input-student-id" placeholder="학번 (예: 20231234)" required class="w-full p-3 border rounded-lg focus:ring-emerald-500 focus:border-emerald-500">
                <input type="tel" id="input-phone" placeholder="전화번호 (예: 010-1234-5678)" required class="w-full p-3 border rounded-lg focus:ring-emerald-500 focus:border-emerald-500">
                <p id="booking-error-msg" class="text-red-500 text-sm hidden"></p>
                
                <button type="submit" id="start-booking-btn" class="w-full p-3 rounded-lg btn-primary" disabled>
                    예매 시작
                </button>
            </form>
            <button onclick="showEventList()" class="w-full mt-3 p-3 rounded-lg bg-gray-200 text-gray-700 hover:bg-gray-300">
                목록으로 돌아가기
            </button>
        </div>

        <!-- 3. Booking View (Seats/Choices) -->
        <div id="booking-view" class="hidden max-w-2xl mx-auto kst-card p-6">
            <h2 class="text-2xl font-bold mb-4 text-gray-800">예매 진행</h2>
            <div class="mb-6 p-3 bg-blue-50 rounded-lg border-l-4 border-blue-500 text-sm">
                <p>예매자: <span id="summary-name" class="font-semibold"></span> (<span id="summary-student-id"></span>)</p>
                <p class="text-xs text-gray-600 mt-1">예매가 완료되면 학번과 선택 항목으로 내역을 조회할 수 있습니다.</p>
            </div>
            
            <div id="booking-content" class="min-h-[200px]">
                <!-- Seats or Choices UI will be rendered here -->
            </div>
            
            <button onclick="showEventList()" class="w-full mt-6 p-3 rounded-lg bg-gray-200 text-gray-700 hover:bg-gray-300">
                예매 포기/목록으로 돌아가기
            </button>
        </div>

        <!-- 4. Admin View -->
        <div id="admin-view" class="hidden">
            <div class="flex justify-between items-center mb-6 pb-2 border-b-2 border-orange-500">
                <h2 class="text-2xl font-bold text-orange-700">관리자 대시보드</h2>
                <button onclick="exitAdminView()" class="px-3 py-1 text-sm rounded bg-gray-200 text-gray-700 hover:bg-gray-300">관리자 모드 종료</button>
            </div>

            <!-- Event Creation/Edit Form -->
            <div class="kst-card p-6 mb-8">
                <h3 id="admin-form-mode" class="text-xl font-semibold mb-4 text-gray-700">새 이벤트 생성 모드</h3>
                <form id="create-event-form" class="space-y-4">
                    <input type="text" id="admin-title" placeholder="이벤트 제목" required class="w-full p-3 border rounded-lg">
                    <textarea id="admin-description" placeholder="이벤트 상세 설명" rows="3" required class="w-full p-3 border rounded-lg"></textarea>
                    
                    <div class="flex gap-4">
                        <label class="block flex-1">
                            <span class="text-sm text-gray-600">예매 시작 시각 (KST)</span>
                            <input type="datetime-local" id="admin-start-time" required class="w-full p-3 border rounded-lg">
                        </label>
                        <label class="block flex-1">
                            <span class="text-sm text-gray-600">예매 종료 시각 (KST)</span>
                            <input type="datetime-local" id="admin-end-time" required class="w-full p-3 border rounded-lg">
                        </label>
                    </div>

                    <label class="block">
                        <span class="text-sm text-gray-600">예매 유형</span>
                        <select id="admin-type" required onchange="handleAdminTypeChange(this)" class="w-full p-3 border rounded-lg">
                            <option value="choices">선택형 (옵션 선택, 선착순)</option>
                            <option value="seats">좌석형 (좌석 지도)</option>
                        </select>
                    </label>

                    <div id="admin-type-config" class="p-3 border rounded-lg bg-gray-50">
                        <!-- Type-specific configuration (choices/seats) -->
                    </div>

                    <p id="admin-error-msg" class="text-red-500 text-sm hidden"></p>
                    
                    <div class="flex gap-4 pt-2">
                        <button type="submit" id="create-event-button" class="flex-1 p-3 rounded-lg bg-orange-600 text-white font-bold hover:bg-orange-700">
                            이벤트 생성
                        </button>
                        <button type="button" onclick="resetAdminForm()" class="p-3 rounded-lg bg-gray-300 text-gray-700 hover:bg-gray-400">
                            초기화
                        </button>
                    </div>
                </form>
            </div>

            <!-- Event Management List -->
            <div class="kst-card p-6">
                <h3 class="text-xl font-semibold mb-4 text-gray-700">등록된 이벤트 관리</h3>
                <div id="admin-event-list" class="space-y-3">
                    <!-- Admin event list will be loaded here -->
                </div>
            </div>
        </div>
    </div>
    
    <!-- Global Loading Indicator -->
    <div id="global-loading" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[100] hidden">
        <div class="bg-white p-6 rounded-xl shadow-2xl flex items-center space-x-3">
            <svg class="animate-spin h-5 w-5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <span id="loading-text" class="text-gray-700 font-medium">처리 중...</span>
        </div>
    </div>
    
    <!-- Global Modal (Generic Confirmation/Alert) -->
    <div id="global-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[90] is-hidden">
        <div id="global-modal-content" class="bg-white p-6 rounded-xl shadow-2xl w-full max-w-md text-center">
            <h3 id="global-modal-title" class="text-xl font-bold mb-4 text-gray-800">제목</h3>
            <div id="global-modal-body" class="text-gray-700 mb-6">내용</div>
            <div id="global-modal-buttons" class="space-x-4">버튼</div>
        </div>
    </div>

    <!-- Queue Modal -->
    <div id="queue-modal" class="fixed inset-0 bg-black bg-opacity-70 items-center justify-center z-[95] is-hidden">
        <div class="bg-white p-8 rounded-xl shadow-2xl w-full max-w-lg text-center transform scale-100 animate-pulse-once">
            <h3 class="text-2xl font-bold text-red-600 mb-2">🚨 예매 대기열 진입</h3>
            <p class="text-gray-600 mb-6">동시 접속자 초과로 인해 대기열에 진입했습니다. 창을 닫지 말고 잠시만 기다려 주세요.</p>
            
            <div class="bg-red-100 p-4 rounded-lg mb-6">
                <p class="text-lg font-semibold text-gray-800">현재 순위: <span id="queue-rank" class="text-2xl text-red-600 font-extrabold">0</span> / <span id="queue-behind">0</span>명 남음</p>
                <div class="w-full bg-gray-200 rounded-full h-2.5 mt-3">
                    <div id="queue-progress" class="bg-green-600 h-2.5 rounded-full transition-all duration-1000" style="width: 100%"></div>
                </div>
            </div>
            
            <p class="text-sm text-gray-500">순위가 되면 자동으로 예매 화면으로 이동합니다.</p>
        </div>
    </div>

    <!-- Booking Complete Modal -->
    <div id="complete-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[90] is-hidden">
        <div class="bg-white p-8 rounded-xl shadow-2xl w-full max-w-md text-center transform scale-100 transition-transform">
            <svg class="mx-auto h-12 w-12 text-green-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>
            <h3 class="text-2xl font-bold text-green-700 mt-3 mb-2">🎉 예매 완료!</h3>
            <p class="text-gray-700 mb-6">성공적으로 예매가 완료되었습니다. 내역을 확인하세요.</p>
            
            <div class="text-left bg-green-50 p-4 rounded-lg border-l-4 border-green-400">
                <p><strong>예매자:</strong> <span id="complete-name"></span></p>
                <p><strong>학번:</strong> <span id="complete-student-id"></span></p>
                <p><strong>예매 번호:</strong> <span id="complete-booking-number" class="text-lg font-bold text-green-600"></span></p>
            </div>
            
            <button onclick="document.getElementById('complete-modal').classList.add('is-hidden'); showEventList();" 
                    class="w-full mt-6 p-3 rounded-lg btn-primary">
                확인 및 목록으로 돌아가기
            </button>
        </div>
    </div>
</body>
</html>
