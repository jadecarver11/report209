<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>2025_HGR209</title>
<style>
  /* Reset */
  *{box-sizing:border-box;margin:0;padding:0}

  html,body{
    height:100%;
    background: linear-gradient(180deg, #020617 0%, #081129 60%, #000814 100%);
    overflow:hidden;
    font-family: "Inter", "Noto Sans KR", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }

  /* 희미한 은하수/성운 효과 */
  .nebula {
    position:fixed;
    inset: -20% -10% auto auto;
    width:140%;
    height:140%;
    background:
      radial-gradient(ellipse at 20% 30%, rgba(120,90,200,0.10), transparent 12%),
      radial-gradient(ellipse at 70% 60%, rgba(40,120,255,0.06), transparent 14%);
    filter: blur(60px) saturate(120%);
    pointer-events:none;
    mix-blend-mode: screen;
  }

  /* 작은 별들 (반짝임) */
  .stars {
    position:fixed;
    inset:0;
    background-image:
      radial-gradient(1px 1px at 10% 20%, rgba(255,255,255,0.9) 50%, transparent 51%),
      radial-gradient(1px 1px at 25% 70%, rgba(255,255,255,0.8) 50%, transparent 51%),
      radial-gradient(1px 1px at 40% 40%, rgba(255,255,255,0.7) 50%, transparent 51%),
      radial-gradient(1px 1px at 60% 20%, rgba(255,255,255,0.85) 50%, transparent 51%),
      radial-gradient(1px 1px at 80% 60%, rgba(255,255,255,0.7) 50%, transparent 51%),
      radial-gradient(1px 1px at 95% 30%, rgba(255,255,255,0.6) 50%, transparent 51%);
    background-size: 100% 100%;
    pointer-events:none;
    opacity:0.8;
    animation: twinkle 4s linear infinite;
  }

  @keyframes twinkle {
    0% { opacity: 0.75; transform: translateY(0); }
    50% { opacity: 1; transform: translateY(-1px); }
    100% { opacity: 0.75; transform: translateY(0); }
  }

  /* 중앙 텍스트 스타일 */
  .center {
    position:fixed;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    pointer-events:none;
  }
  .center .big {
    color: #ffffff;
    font-weight: 800;
    font-size: clamp(48px, 18vw, 220px); /* 반응형 폰트 크기 */
    letter-spacing: 6px;
    text-shadow:
      0 2px 12px rgba(0,0,0,0.6),
      0 0 30px rgba(255,255,255,0.08),
      0 0 80px rgba(120,100,255,0.06);
    line-height: 0.9;
    mix-blend-mode: screen;
  }

  /* Meteor container */
  .meteors {
    position:fixed;
    inset:0;
    pointer-events:none;
    overflow:visible;
  }

  /* 유성(스타일) */
  .meteor {
    position:absolute;
    top:-10vh; /* 시작 위치는 화면 위 */
    right:-10vw; /* 화면 오른쪽 바깥에서 시작 (대각선으로 내려옴) */
    width: 2px;
    height: 120px;
    border-radius: 50%;
    transform-origin: left top;
    filter: drop-shadow(0 6px 12px rgba(0,0,0,0.6));
    will-change: transform, opacity;
    opacity:0;
    pointer-events:none;
  }

  /* 유성 안의 빛(그라디언트) */
  .meteor::before {
    content:"";
    position:absolute;
    left:0;
    top:0;
    width:100%;
    height:100%;
    background: linear-gradient(90deg,
      rgba(255,255,255,0.95) 0%,
      rgba(255,220,160,0.9) 20%,
      rgba(255,140,60,0.6) 50%,
      rgba(0,0,0,0) 100%);
    transform: translateX(-10%) rotate(-20deg);
    border-radius: 50%;
    filter: blur(1px);
  }

  /* 꼬리(밝은 희미한 트레일) */
  .meteor::after {
    content:"";
    position:absolute;
    left:-150%;
    top:30%;
    width:300%;
    height:40%;
    background: linear-gradient(90deg, rgba(255,255,255,0.6), rgba(255,255,255,0.12), rgba(255,255,255,0));
    transform: rotate(-20deg) translateX(-20%);
    filter: blur(6px) contrast(120%);
    border-radius: 50%;
    opacity:0.95;
  }

  /* 유성 애니메이션 (공용) */
  @keyframes fall {
    0% {
      transform: translate3d(0, -10vh, 0) rotate(-25deg) scaleY(0.6);
      opacity: 0;
    }
    8% {
      opacity: 1;
      transform: translate3d(0, 0vh, 0) rotate(-25deg) scaleY(1);
    }
    92% {
      opacity: 1;
    }
    100% {
      transform: translate3d(-120vw, 120vh, 0) rotate(-25deg) scaleY(1.1);
      opacity: 0;
    }
  }

  /* 접근성: 모션 줄이기 옵션 지원 */
  @media (prefers-reduced-motion: reduce) {
    .meteor { animation: none !important; opacity: 0.7; }
    .stars, .nebula { animation: none !important; }
  }

  /* 화면이 좁으면 꼬리 길이 줄이기 (성능 안정화) */
  @media (max-width:600px) {
    .meteor { height: 80px; }
    .center .big { letter-spacing: 3px; }
  }
</style>
</head>
<body>
  <div class="nebula" aria-hidden="true"></div>
  <div class="stars" aria-hidden="true"></div>

  <div class="meteors" id="meteors" aria-hidden="true"></div>

  <div class="center" role="banner" aria-label="메인 텍스트">
    <div class="big">2025209</div>
  </div>

<script>
/*
  간단한 유성 생성기 (JS)
  - 페이지 로드 후 주기적으로 유성을 생성
  - 랜덤한 위치, 크기, 속도, 지연시간으로 다양하게 표시
  - 생성 수량을 8~14개로 제한하여 성능 영향 최소화
*/

(function(){
  const container = document.getElementById('meteors');
  const MAX_METEORS = 12;
  const SPAWN_INTERVAL = 700; // ms 간격 (랜덤으로 변동)

  function makeMeteor() {
    const m = document.createElement('div');
    m.className = 'meteor';

    // 랜덤 시작 위치 (오른쪽 위 바깥 영역), y는 0~35% 높이에서 시작
    const startTop = Math.random() * 40; // vh %
    const startRight = Math.random() * 10; // vw % (off-screen)
    m.style.top = startTop + 'vh';
    m.style.right = startRight + 'vw';

    // 길이와 두께 랜덤
    const len = 80 + Math.random() * 160; // px
    const thickness = 1 + Math.random() * 3; // px
    m.style.height = len + 'px';
    m.style.width = thickness + 'px';

    // 크기(스케일)에 따라 애니메이션 시간과 지연 조정
    const speed = 1.6 + Math.random() * 2.6; // 클수록 느림 (초)
    const duration = (6 / speed) + (Math.random() * 2); // 초
    const delay = Math.random() * 3; // 초

    // 각도를 조금 섞어서 자연스럽게
    const angle = -18 - Math.random() * 14; // degree
    m.style.transform = `rotate(${angle}deg)`;

    // 애니메이션 적용 (fall 키프레임 사용)
    m.style.animation = `fall ${duration}s linear ${delay}s forwards`;

    // 투명도 및 밝기 약간 랜덤
    m.style.opacity = 0;
    m.style.filter = `brightness(${0.9 + Math.random()*1.4}) blur(${Math.random()*1.5}px)`;

    container.appendChild(m);

    // 애니메이션이 끝나면 제거
    const totalMS = (duration + delay) * 1000 + 500;
    setTimeout(() => {
      m.remove();
    }, totalMS);
  }

  // 초반에 몇 개 미리 생성
  for (let i=0;i<4;i++){
    setTimeout(makeMeteor, i*350);
  }

  // 정기적으로 생성 (랜덤 간격)
  let running = true;
  function schedule(){
    if(!running) return;
    // 제어: 현재 화면에 있는 유성 개수 체크
    const current = container.querySelectorAll('.meteor').length;
    if (current < MAX_METEORS) {
      makeMeteor();
    }
    const next = SPAWN_INTERVAL + Math.random()*800;
    setTimeout(schedule, next);
  }
  schedule();

  // 페이지 가려지면 애니메이션 과도한 생성 막기
  document.addEventListener('visibilitychange', () => {
    running = document.visibilityState === 'visible';
  });
})();
</script>
</body>
</html>
